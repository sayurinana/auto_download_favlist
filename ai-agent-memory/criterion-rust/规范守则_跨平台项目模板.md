# AI_AGENT.md - 跨平台项目规范守则

这是针对需要在多个操作系统平台运行的Rust项目的通用AI代理规范守则文档。

## 项目类型
跨平台应用程序(Cross-Platform Application)

## 支持平台
- Windows (x86_64-pc-windows-msvc)
- macOS (x86_64-apple-darwin, aarch64-apple-darwin)
- Linux (x86_64-unknown-linux-gnu)

## 核心要求

### 平台兼容性
- 使用标准库而非平台特定API
- 路径处理使用`std::path`模块
- 文件权限使用跨平台抽象
- 网络代码考虑IPv4/IPv6兼容

### 条件编译
- 使用`#[cfg()]`属性处理平台差异
- 最小化平台特定代码
- 为平台特定功能提供回退方案
- 清楚文档化平台限制

### 构建系统
- 支持主流平台的交叉编译
- CI/CD覆盖所有目标平台
- 自动化构建和发布流程
- 依赖项平台兼容性验证

## 推荐依赖
```toml
[dependencies]
# 跨平台系统交互
dirs = "5.0"              # 标准目录路径
home = "0.5"              # 用户主目录
which = "6.0"             # 可执行文件查找

# 跨平台进程和信号处理
ctrlc = "3.4"             # Ctrl+C信号处理
signal-hook = "0.3"       # Unix信号处理

# 跨平台终端操作
crossterm = "0.27"        # 终端控制
console = "0.15"          # 终端交互

# 文件系统操作
walkdir = "2.4"           # 目录遍历
notify = "6.0"            # 文件系统监控

# 平台检测
cfg-if = "1.0"
```

## 平台特定依赖
```toml
[target.'cfg(windows)'.dependencies]
winapi = { version = "0.3", features = ["winuser", "processthreadsapi"] }
windows = { version = "0.52", features = ["Win32_System_Console"] }

[target.'cfg(unix)'.dependencies]
nix = "0.27"
libc = "0.2"

[target.'cfg(target_os = "macos")'.dependencies]
core-foundation = "0.9"
```

## 项目结构
```
src/
├── lib.rs               # 通用库接口
├── main.rs              # 主程序入口
├── platform/            # 平台特定代码
│   ├── mod.rs
│   ├── windows.rs       # Windows特定实现
│   ├── unix.rs          # Unix通用实现
│   ├── macos.rs         # macOS特定实现
│   └── linux.rs         # Linux特定实现
├── core/                # 平台无关核心逻辑
│   ├── mod.rs
│   └── processor.rs
└── utils/               # 跨平台工具函数
    ├── mod.rs
    ├── paths.rs         # 路径处理
    └── process.rs       # 进程管理
```

## 代码模板

### 平台抽象接口
```rust
/// 跨平台系统操作抽象
pub trait PlatformOps {
    /// 获取系统信息
    fn get_system_info(&self) -> Result<SystemInfo, PlatformError>;
    
    /// 执行平台特定操作
    fn platform_specific_action(&self) -> Result<(), PlatformError>;
    
    /// 获取默认配置路径
    fn get_config_dir(&self) -> Result<PathBuf, PlatformError>;
}

/// 获取当前平台的实现
pub fn get_platform_ops() -> Box<dyn PlatformOps> {
    #[cfg(windows)]
    return Box::new(platform::windows::WindowsOps::new());
    
    #[cfg(target_os = "macos")]
    return Box::new(platform::macos::MacOsOps::new());
    
    #[cfg(target_os = "linux")]
    return Box::new(platform::linux::LinuxOps::new());
    
    #[cfg(not(any(windows, target_os = "macos", target_os = "linux")))]
    return Box::new(platform::unix::UnixOps::new());
}
```

### 路径处理
```rust
use std::path::{Path, PathBuf};

/// 跨平台路径工具
pub struct PathUtils;

impl PathUtils {
    /// 规范化路径分隔符
    pub fn normalize_path<P: AsRef<Path>>(path: P) -> PathBuf {
        let path = path.as_ref();
        
        // 处理Windows UNC路径
        #[cfg(windows)]
        {
            if let Some(s) = path.to_str() {
                if s.starts_with("\\\\") {
                    return PathBuf::from(s.replace('/', "\\"));
                }
            }
        }
        
        path.to_path_buf()
    }
    
    /// 获取可执行文件扩展名
    pub fn exe_extension() -> &'static str {
        #[cfg(windows)]
        return ".exe";
        
        #[cfg(not(windows))]
        return "";
    }
    
    /// 获取配置目录
    pub fn get_config_dir(app_name: &str) -> Result<PathBuf, std::io::Error> {
        let config_dir = dirs::config_dir()
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "无法确定配置目录"
            ))?;
        
        Ok(config_dir.join(app_name))
    }
    
    /// 检查路径是否为绝对路径（跨平台）
    pub fn is_absolute<P: AsRef<Path>>(path: P) -> bool {
        let path = path.as_ref();
        
        #[cfg(windows)]
        {
            // Windows路径检查
            if let Some(s) = path.to_str() {
                return s.len() >= 3 && s.chars().nth(1) == Some(':') ||
                       s.starts_with("\\\\");
            }
        }
        
        path.is_absolute()
    }
}
```

### 进程管理
```rust
use std::process::{Child, Command, Stdio};

/// 跨平台进程管理
pub struct ProcessManager;

impl ProcessManager {
    /// 启动子进程
    pub fn spawn_process(
        program: &str,
        args: &[&str],
    ) -> Result<Child, std::io::Error> {
        let mut cmd = Command::new(program);
        cmd.args(args);
        
        // 平台特定配置
        #[cfg(windows)]
        {
            use std::os::windows::process::CommandExt;
            cmd.creation_flags(0x00000008); // CREATE_NO_WINDOW
        }
        
        #[cfg(unix)]
        {
            use std::os::unix::process::CommandExt;
            // Unix特定配置
            cmd.stdin(Stdio::null());
        }
        
        cmd.spawn()
    }
    
    /// 查找可执行文件
    pub fn find_executable(name: &str) -> Option<PathBuf> {
        // 添加平台特定扩展名
        let exe_name = format!("{}{}", name, PathUtils::exe_extension());
        
        which::which(&exe_name)
            .or_else(|_| which::which(name))
            .ok()
    }
    
    /// 获取当前进程ID
    pub fn current_pid() -> u32 {
        #[cfg(windows)]
        {
            unsafe { winapi::um::processthreadsapi::GetCurrentProcessId() }
        }
        
        #[cfg(unix)]
        {
            unsafe { libc::getpid() as u32 }
        }
    }
}
```

### 信号处理
```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

/// 跨平台信号处理
pub struct SignalHandler {
    shutdown_requested: Arc<AtomicBool>,
}

impl SignalHandler {
    pub fn new() -> Self {
        let shutdown_requested = Arc::new(AtomicBool::new(false));
        
        // 设置Ctrl+C处理
        let shutdown_flag = shutdown_requested.clone();
        ctrlc::set_handler(move || {
            shutdown_flag.store(true, Ordering::SeqCst);
        }).expect("无法设置Ctrl+C处理器");
        
        // 平台特定信号处理
        #[cfg(unix)]
        {
            let shutdown_flag = shutdown_requested.clone();
            let _ = signal_hook::flag::register(
                signal_hook::consts::SIGTERM,
                shutdown_flag.clone()
            );
        }
        
        Self { shutdown_requested }
    }
    
    pub fn should_shutdown(&self) -> bool {
        self.shutdown_requested.load(Ordering::SeqCst)
    }
    
    pub fn wait_for_signal(&self) {
        while !self.should_shutdown() {
            std::thread::sleep(std::time::Duration::from_millis(100));
        }
    }
}
```

### 平台检测
```rust
/// 平台信息
#[derive(Debug, Clone)]
pub struct PlatformInfo {
    pub os: String,
    pub arch: String,
    pub family: String,
}

impl PlatformInfo {
    pub fn current() -> Self {
        Self {
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),
            family: std::env::consts::FAMILY.to_string(),
        }
    }
    
    pub fn is_windows(&self) -> bool {
        self.family == "windows"
    }
    
    pub fn is_unix(&self) -> bool {
        self.family == "unix"
    }
    
    pub fn is_macos(&self) -> bool {
        self.os == "macos"
    }
    
    pub fn is_linux(&self) -> bool {
        self.os == "linux"
    }
}
```

## 构建配置

### Cargo.toml
```toml
[package]
name = "cross-platform-app"
version = "0.1.0"
edition = "2021"

# 支持的平台
[[target]]
name = "x86_64-pc-windows-msvc"

[[target]] 
name = "x86_64-unknown-linux-gnu"

[[target]]
name = "x86_64-apple-darwin"

[[target]]
name = "aarch64-apple-darwin"

[features]
default = ["terminal-ui"]
terminal-ui = ["crossterm", "console"]
```

### 交叉编译脚本
```bash
#!/bin/bash
# build-all-platforms.sh

set -e

TARGETS=(
    "x86_64-pc-windows-msvc"
    "x86_64-unknown-linux-gnu" 
    "x86_64-apple-darwin"
    "aarch64-apple-darwin"
)

for target in "${TARGETS[@]}"; do
    echo "构建 $target..."
    cargo build --release --target "$target"
done

echo "所有平台构建完成！"
```

## 测试策略
- 在所有支持平台运行测试
- 使用条件编译测试平台特定功能
- 模拟平台差异进行边界测试
- 集成测试验证跨平台行为一致性

## CI/CD配置
```yaml
strategy:
  matrix:
    include:
      - os: ubuntu-latest
        target: x86_64-unknown-linux-gnu
      - os: windows-latest  
        target: x86_64-pc-windows-msvc
      - os: macos-latest
        target: x86_64-apple-darwin
      - os: macos-latest
        target: aarch64-apple-darwin
```

## 发布注意事项
- 为每个平台提供预编译二进制文件
- 测试所有平台的安装和运行
- 平台特定的安装说明
- 处理平台差异的用户文档
